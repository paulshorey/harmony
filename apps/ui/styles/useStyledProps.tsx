import { useEffect, useState } from 'react';
import { css, useTheme } from '@emotion/react';
import { cx, css as emotionClassName } from '@emotion/css';
import style_to_string from '@ps/fn/browser/style/style_to_string';
import { returnDeviceInfo, deviceInfoType } from '@ps/ui/hooks/useDeviceInfo';
import { ssProp } from '@ps/ui/types/styles';

type Props = {
  /*
   * All the props that were passed to your component. Style props are prefixed with "ss". Also variant, textcolor, bgcolor, textgradient, bggradien,.
   */
  props: any;
  /*
   * The name of the component. Unique per component. Required. Will be used to label added classNames, for added specificity. Also helpful when looking in the browser Dev Tools, to know which div was generated by which component.
   */
  componentName: string;
  /*
   * Object of Emotion styles. Each value can be css``, array of css``, or a function that returns css``.
   * This can also be strings instead of css``. For convenience: string, strings[], (props)=>string.
   */
  variants?: Record<string, ssProp>;
  /*
   * Imported CSS Modules file. From `index.module.css` in the same folder as your  component. CSS Modules act like classic CSS Stylesheets. They allow the scoped style to reference parent/grandparent DOM elements. See if your current component is rendered inside a "light" or "dark", "purple" or "orange" section. JS can't see that.
   */
  classes?: Record<string, string>;
};

/**
 * This is a helper function that returns a modified props object. It does not change the original props object.
 * This removes all the props unique to this library styling-system like `ss`, `ssLg`, `ssDesktop`, `ssMobile`.
 */
export default ({
  props: inputProps,
  componentName,
  variants: emotionStyles,
  classes: cssModules,
}: Props): Record<string, any> => {
  const {
    variant,
    textcolor = '',
    textgradient = '',
    bgcolor = '',
    bggradient = '',
    ss,
    ssAll,
    ssAndroid,
    ssDesktop,
    ssIPad,
    ssIPhone,
    ssIframe,
    ssLandscape,
    ssLargeDesktop,
    ssLargeTablet,
    ssLg,
    ssLinux,
    ssMac,
    ssMobile,
    ssNotIframe,
    ssNotPhone,
    ssNotWebview,
    ssPhone,
    ssPortrait,
    ssSm,
    ssSmallPhone,
    ssTablet,
    ssTinyPhone,
    ssVeryLargeDesktop,
    ssWebview,
    ssWindows,
    ...props
  } = inputProps;
  const theme: any = useTheme();
  props.theme = theme;

  // styled strings
  let ssVariants = '';
  let ssInline = '';

  // variants
  // style functions/objects
  if (emotionStyles) {
    if (emotionStyles.default) {
      ssVariants += style_to_string(emotionStyles.default, props);
    }
    if (variant && emotionStyles[variant]) {
      ssVariants += style_to_string(emotionStyles[variant], props);
    }
  }

  // For each device and size, add a media query (but only if custom style for it is specified)
  const checkDeviceInfo =
    ssIframe ||
    ssNotIframe ||
    ssWebview ||
    ssNotWebview ||
    ssIPhone ||
    ssIPad ||
    ssMac ||
    ssWindows ||
    ssLinux ||
    ssAndroid;

  // This will re-style the component on the client, after Window/browser is available
  const [deviceInfo, set_deviceInfo] = useState<deviceInfoType>();
  useEffect(() => {
    if (checkDeviceInfo) {
      set_deviceInfo(returnDeviceInfo());
    }
  }, []);

  if (ss) {
    ssInline += `\n${style_to_string(ss, props)}\n`;
  }
  if (ssAll) {
    ssInline += `${theme.mq.all} { ${style_to_string(ssAll, props)} }\n`;
  }
  if (ssLg) {
    ssInline += `${theme.mq.lg} { ${style_to_string(ssLg, props)} }\n`;
  }
  if (ssSm) {
    ssInline += `${theme.mq.sm} { ${style_to_string(ssSm, props)} }\n`;
  }
  if (ssDesktop) {
    ssInline += `${theme.mq.desktop} { ${style_to_string(
      ssDesktop,
      props
    )} }\n`;
  }
  if (ssMobile) {
    ssInline += `${theme.mq.mobile} { ${style_to_string(ssMobile, props)} }\n`;
  }
  if (ssTablet) {
    ssInline += `${theme.mq.tablet} { ${style_to_string(ssTablet, props)} }\n`;
  }
  if (ssLargeTablet) {
    ssInline += `${theme.mq.largeTablet} { ${style_to_string(
      ssLargeTablet,
      props
    )} }\n`;
  }
  if (ssNotPhone) {
    ssInline += `${theme.mq.notPhone} { ${style_to_string(
      ssNotPhone,
      props
    )} }\n`;
  }
  if (ssPhone) {
    ssInline += `${theme.mq.phone} { ${style_to_string(ssPhone, props)} }\n`;
  }
  if (ssSmallPhone) {
    ssInline += `${theme.mq.smallPhone} { ${style_to_string(
      ssSmallPhone,
      props
    )} }\n`;
  }
  if (ssTinyPhone) {
    ssInline += `${theme.mq.tinyPhone} { ${style_to_string(
      ssTinyPhone,
      props
    )} }\n`;
  }
  if (ssLargeDesktop) {
    ssInline += `${theme.mq.largeDesktop} { ${style_to_string(
      ssLargeDesktop,
      props
    )} }\n`;
  }
  if (ssVeryLargeDesktop) {
    ssInline += `${theme.mq.veryLargeDesktop} { ${style_to_string(
      ssVeryLargeDesktop,
      props
    )} }\n`;
  }
  if (ssPortrait) {
    ssInline += `${theme.mq.portrait} { ${style_to_string(
      ssPortrait,
      props
    )} }\n`;
  }
  if (ssLandscape) {
    ssInline += `${theme.mq.landscape} { ${style_to_string(
      ssLandscape,
      props
    )} }\n`;
  }
  if (ssMac) {
    ssInline += `${
      deviceInfo?.device === 'Mac' && `${style_to_string(ssMac, props)}`
    }\n`;
  }
  if (ssWindows) {
    ssInline += `${
      deviceInfo?.device === 'Windows' && `${style_to_string(ssWindows, props)}`
    }\n`;
  }
  if (ssLinux) {
    ssInline += `${
      deviceInfo?.device === 'Linux' && `${style_to_string(ssLinux, props)}`
    }\n`;
  }
  if (ssAndroid) {
    ssInline += `${
      deviceInfo?.device === 'Android' && `${style_to_string(ssAndroid, props)}`
    }\n`;
  }
  if (ssIPad) {
    ssInline += `${
      deviceInfo?.device === 'iOS' && `${style_to_string(ssIPad, props)}`
    }\n`;
  }
  if (ssIPhone) {
    ssInline += `${
      deviceInfo?.device === 'iPhone' && `${style_to_string(ssIPhone, props)}`
    }\n`;
  }
  if (ssIframe && deviceInfo?.inIframe) {
    ssInline += `${style_to_string(ssIframe, props)}\n`;
  }
  if (ssNotIframe && !deviceInfo?.inIframe) {
    ssInline += `${style_to_string(ssNotIframe, props)}\n`;
  }
  if (ssWebview && deviceInfo?.inWebview) {
    ssInline += `${style_to_string(ssWebview, props)}\n`;
  }
  if (ssNotWebview && !deviceInfo?.inWebview) {
    ssInline += `${style_to_string(ssNotWebview, props)}\n`;
  }

  /*
   * Modify className to include the generated styles
   */
  props.className = (props.className || '') + ' ' + componentName;
  // apply newly-generated className
  props.className = cx(
    props.className,
    emotionClassName(css`
      &.${componentName} {
        ${ssVariants};
        ${ssInline}
      }
    `)
  );
  if (cssModules) {
    if (cssModules.default) {
      props.className += ' ' + cssModules.default;
    }
    if (variant && cssModules[variant]) {
      props.className += ' ' + cssModules[variant];
    }
  }

  /*
   * Modify data- attributes to allow CSS to "Cascade" and add light/dark colors based on parents and grandparents
   */
  if (bgcolor || bggradient) {
    props['data-bgcolor'] = bgcolor || bggradient;
    if (bggradient) {
      props['data-bggradient'] = true;
    }
  }
  if (textcolor || textgradient) {
    props['data-textcolor'] = textcolor || textgradient;
    if (textgradient) {
      props['data-textgradient'] = true;
    }
  }
  if (props['data-textcolor'] === 'light') {
    props['data-colorscheme'] = 'dark';
  } else if (props['data-textcolor'] === 'dark') {
    props['data-colorscheme'] = 'light';
  } else if (props['data-bgcolor'] === 'light') {
    props['data-colorscheme'] = 'light';
  } else if (props['data-bgcolor'] === 'dark') {
    props['data-colorscheme'] = 'dark';
  }

  /*
   * return
   */
  delete props.theme;
  return props;
};
