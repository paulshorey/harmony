import { Canvas, Meta, Story, ArgsTable } from '@storybook/addon-docs';
import Text from '@ps/ui/components/content/Box';
import ThemeProvider from '@ps/ui/components/utils/ThemeProvider';
import { Wrapper } from '../../components/Components';
import Box from '@ps/ui/components/content/Box';
import Code from '@ps/ui/components/content/Code';

export const Template = (args) => (
  <Box as="p" {...args}>
    Component
  </Box>
);

<Meta
  title="core/Colors and shades"
  component={Box}
  argTypes={{
    fluid: {
      name: 'fluid',
      description: 'Let the container grow to max',
      table: {},
      control: {
        type: 'boolean',
      },
    },
  }}
/>

<ThemeProvider>

<Wrapper>
  <h2 className="text-3xl font-bold underline">This is not a UI Component Library...</h2>
  <hr />
  <h3>
    It's a starter kit for easily making <Box as="span" className="text-rainbow"> and branding </Box> your own UI library.
  </h3>

<Code code={`import { Box } from '@ps/ui/components/content/Box';`} />

<p>
  <strong>It's a styling-system for enterprise.</strong>
  <br />
  Scalable, with shortcuts for media queries, devices, variables, and colors
  schemes.
</p>
<p>
  Great for a mono-repo. This library can be imported by multiple apps. Each app
  can extend the base theme and functionality.
</p>
<p>
  This is a work in progress, but already useful.{' '}
  <span className="noWrap">Read more:</span>
</p>
<ul>
  <li>
    <a href="/">media queries</a> - easily style breakpoints (with JSX props, JS
    variables, or Styled Components HOC)
  </li>
  <li>
    <a href="/">variants and themes</a> - use/extend multiple predefined
    variants (like classNames but with Typescript)
  </li>
</ul>

  <hr />
  <h3>Funny thing...</h3>
  <p>
    The "C" in "CSS" stands for "Cascading" - each more specific set of rules inherits from / extends the previous. But, so-called CSS-in-JS solutions
    actually don't support the "C" part. They're usually just S-in-JS. But that's not as catchy. ðŸ˜†{" "}
  </p>
  <p>
    This library attempts to bring back the Cascading functionality. It's not finished, but there's already some inheritance of variants. Variants are like
    classNames. Variant styles can see what other variants/colors/sizes/etc are used in the component just like classNames were able to refer to sibling or
    child classNames.
  </p>
  <hr />
  <h3>This project is made to replace the following patterns:</h3>
  <ol>
    <li>Install a 3rd-party open-source UI component library</li>
    <li>
      Find a compatible styling solution to customize that component library. You'll need to make a new component for each 3rd-party component to override
      its styles, essentially building your own custom component library. Or, if the component library uses class names, then you'll have to manage a long
      complex stylesheet of overrides.
    </li>
  </ol>
  <Box as="h4" ss="margin-top:0;">
    or
  </Box>
  <ol>
    <li>Build your own custom component library from scratch.</li>
    <li>Set up your own styling system, variables, and media queries.</li>
    <li>Manage functions/hooks/helpers to handle user interactions and device specific edge cases.</li>
  </ol>
  <h4>Instead, you can</h4>
  <ol>
    <li>Use this starter component library, or copy the entire mono-repo.</li>
    <li>
      As you build out your product/app/website, add a new component as needed with a good base functionality and styles to suit any of your apps. Add more
      properties to the theme, hooks, helpers, whatever you need.
    </li>
    <li>In each app, extend this library's theme to match the app's specific requirements.</li>
  </ol>
  <hr />
  <h3>This is powered by EmotionJS</h3>
  <p>
    You can pass an EmotionJS object or function to any of the `ss` props - without having to set up the `` prop in your own app. Just use `ss` instead. To
    style in a media query, pass `ssLg`/`ssSm`, `ssDesktop`/`ssMobile`, `ssPhone`, `ssSmallPhone`, etc. All ss props also accept string type. They will be
    inserted into an EmotionJS function after being wrapped in the appropriate media query.
  </p>
  <hr />
  <h3>Typescript and testing</h3>
  <p>
    Theme, colors, variants, css variables, hooks, functions, and everything else here is written in Typescript. But css properties themselves are old
    fashioned strings. That's actually ok. With current tooling, it's actually not even possible to effectively type check CSS properties. Consider padding
    "1em 2em calc(1em+5px)" (forgot spaces around the plus) or "1ems" (typo s character). Type is correct, but it's not valid css. There are many edge cases
    with styling that Typescript will not catch even if the variable type is correct. It's not worth the effort to do CSS-in-JS objects, because "visual
    regression testing" is much more effective at preventing styling regressions.
  </p>
  <p>
    Unit tests are important and coming soon to this library. But, this library is not yet stable. Unit tests are great for ensuring specific in/out
    functionality does not change. But right now functionality is still changing. The function library @ps/fn that's a sibling to this package does already
    have unit tests in place. Open that and run `yarn dev`. The goal is to have the same with this library.
  </p>
  <p>
    Since this library is mostly visual however, the more immediate plan is to put in visual regression tests that run before Git can push changes. Coming
    son.
  </p>
</Wrapper>

</ThemeProvider>
