# A confusing trend in web development

I notice software engineers like to write CSS rules in JavaScript format even though it's more tedious and less useful. Somebody please give me a valid supporting argument. I've always tried to understand the opposing argument, but am yet to hear any rational argument in favor of JSS.

This codebase uses Typescript for everything - except for css properties. Typescript is actually not able to verify the validity of css values and is not a good tool for validating colors and appearance. It's better to use visual regression or snapshot tests to verify how components look. For example, `{ padding: 'calc(100%-20px)' }` is a valid type, but not valid CSS. Same with `{ color: 'hsl(200, 75%, 75%)' }`.  

So if Typescript can't validate CSS properties, there's no point changing the format of the standard CSS. Sure, converting to camelCase from dashed-case is not a problem. But pseudo-selectors, children, media queries are more difficult - sometimes impossible, so sometimes you still have to use real CSS, leading to an inconsistent codebase. More annoyingly, JSS needs everything to be wrapped in quotes. That's many more characters to type. And, you can't just copy/paste from Dev Tools and online sorouces.


<Code
  variant="transparentDark"
  code={`{/* JSS */}
<Block ss={ {color:'red'} }>  
<Block ss={ (props) => ({color: props.theme.colors.error }) }>
{/* Emotion */}
<Block ss={ css\` color:red; \` }>
<Block ss={(props) => css\` color: \${props.theme.colors.error}; \`}>
{/* string */}
<Block ss="color:red">
<Block ss={ (props) => \` color: \${props.theme.colors.error}; \` }>`} />


### Maintainable

- Great developer experience. Easily manage media queries, variables, colors, markup, and interactive functionality. Tree shaking by default.

### Mono-repo

- Maintain just one set of components and styles. Import into multiple apps. If one app needs unique style or functionality, it's easy to override both.

### Extensible

- Add functionality and style to the base library as a "variant". Then select that variant in your app. This way if you need to customize a component, you don't have to duplicate code. Extend a component for one app without affecting other apps.

<br />

- <a href="/" color="accent">
    Media queries
  </a> - you can easily style for multiple devices with JSX props, JS variables,
  or Styled Components
- <a href="/">Variants and variables</a> - choose from any variant, add a new one,
  use color/scheme/props in your styles

<p>
  <Inline as="b" textgradient="accent">
    ðŸ’¡ Not just for styling &ndash;
  </Inline>{' '}
  <a>
    use variants to <b>add new JS functionality</b>
  </a>{' '}
  without <b>breaking or complicating</b> existing implementations.
  <br />
  &nbsp;
</p>

{' '}

<br />
In the future, would be nice to use <a
  href="https://github.com/BuilderIO/mitosis"
  target="_blank"
>
  Mitosis
</a> to transpile these <Inline
  as="strong"
  variant="textcolorUnderlined"
>
  React
</Inline> components to any other JS framework.

This library does **not** attempt to **replace CSS** functionality like so many CSS-in-JS libraries. Instead it lets JS do what it's good at (define logic and state) while letting CSS do what it's good at (setting the color scheme on a parent that can later be accessed from a child element, without having to prop-drill or style each individual element separately). This is "CSS-and-JS" living in harmony.

This library is completely written in Typescript. **Except** for CSS styles. That's because Typescript is actually incapable of checking validity of CSS rules. So, there's no reason to use the more verbose JavaScript notation over the quick and easy CSS strings. For example, you can define the type of `padding` as `string | number`. But then you pass `1rem2rem` or `calc(10%+10px)` and it breaks because it's missing a space. Typescript can't catch that. If you know of a way, please reach out! I'd love to learn.

However, I love Typescript. It's great for almost everything else. So even though CSS and color variables are not typed (because it's pointless and **visual regression** testing is much better for visual stuff anyway), everything else is type safe. At least that's the goal. This library is still very experimental and in flux. Still adding stricter types and unit tests.

<Code
  variant="transparentDark"
  code={`const SvgSparkle = withBlock({
  as: 'svg',
  ss: \`display:inline-block;position:absolute;width:0;height:0;color:var(--colors-accent);\`,
  children: <path d="..." fill="currentColor" />,
});
...
<SvgSparkle ss="top:-1rem;" />multi-repo<SvgSparkle ss="bottom:-1rem;" />`}
/>

There are many UI component libraries out there, especially for React. But they all have limitations. <a>Here's a comparison.</a> Building your own is a big investment and can get messy. Not anymore!

<Code
variant="transparentDark"
code={`import Span from '@ps/ui/components/content/Span';
...

{' '}

<Span variant="gradient" color="accent">
  your own
</Span> <Span variant="textcolorUnderline" color="rainbow">
  {' '}
  custom branded{' '}
</Span>
`} caption=
{
  <>
    Easy!{' '}
    <a href="/?path=/docs/about-200--page" target="_top">
      Read about the Media Query shortcuts!
    </a>
  </>
}
/>

<Code
  variant="transparentLight"
  prismTheme={{ plain: { backgroundColor: 'beige' } }}
  code={`<Code 
  variant="transparentDark" 
  code={\`import Span from '@ps/ui/components/content/Span';
  ...
  <Span variant="gradient" color="accent">your own</Span> <Span variant="textcolorUnderline" color="rainbow"> custom branded </Span>
  \`}
  caption={<>Easy! And wait till you <a href="/?path=/docs/about-200--page" target="_top">read about the Media Query shortcuts!</a></>}
/>`}
  caption="Here is how the previous component was rendered"
/>

<br />

## Compatible with most component libraries.

**Peer dependencies:**

- React
- Typescript
- @emotion/styled (just like styled-components)
- @emotion/react (load global styles and theme)
- Next (optional, required for components that use next/link) \*/}

<br />

## Putting the "C" back into "CSS"...

The "C" in "CSS" stands for "Cascading" - styles can be applied based on parent/grandparent styles/variables. Unfortunately, this is lost in modern "CSS-in-JS" solutions. They should be called "S-in-JS", but that's not as catchy. ðŸ˜†

This library attempts to bring back inheritance to style rules, but without the class name conflicts. Components should be able to know if they are inside a dark theme or on top of a color gradient, and adjust the text/button colors automatically. Using CSS variables and HTML data attributes, components are able to adapt to their surroundings, without the developer having to set a specific color shade and subtle style rules for each instance of a component

It's a work in progress. This library is not ready for production use yet, but so far it's looking promising! ðŸš€ Now testing and optimizing.
