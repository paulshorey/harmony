import { Meta, Story, Canvas } from '@storybook/addon-docs';
import Block from '@ps/ui/components/Block';
import Inline from '@ps/ui/components/Inline';
import CodeInline from '@ps/ui/components/CodeInline';
import ThemeProvider from '@ps/ui/components/ThemeProvider';
import Wrapper from '@ps/ui/.storybook/components/Wrapper';
import {
  Container,
  ButtonCTA,
  CanvasContainer,
  CanvasContent,
  Title,
  Content,
  Button,
} from '@ps/ui/.storybook/components/Components';
import Code from '@ps/ui/components/Code';

<Meta title="Get started/Styles and props" />

<ThemeProvider>
<Wrapper>

# There are multiple ways to use these components:

<br />

## 1. The default export is ready to use

<Code
  ss="font-size: 0.85rem;"
  code={`import Button from "@ps/ui/components/content/Button";
  
<Button variant="outlined" onClick={console.log} ss={\`/* like @emotion/react inline css prop but with zero configuration */\`}>
  Click me
</Button>`}
/>

## 2. HOC just like Styled Components

This library is powered by `styled-components`. Just like <CodeInline code={`styled.button\`\``}/> or <CodeInline code={`styled.div\`\``}/>, you can use <CodeInline code={`withButton()`}/> or <CodeInline code={`withDiv()`}/>  

**An added feature:** pre-define <Inline as="b" textcolor="accent"> props</Inline> as well as styles. This is a great way to keep your code clean, separate markup from style, data-generated props from unique manually added props. Separate concerns: common pre-defined props vs unique per-instance props.

<Code
  ss="font-size: 0.85rem;"
  code={`import { withButton } from "@ps/ui/components/Button";
  
// Pre-define any props you may need. These will apply to all instance:
  
export const MyButton = withButton({
  size: 'small',
  round: true,
  ss: \`
    margin: 0 0.875rem 0.875rem 0; /* and other styles */
  \`,
  ssDesktop: \`
    &:hover { box-shadow: 1px 2px 1px var(--color-cta); } /* styles in addition to props.ss */
  \`,
  trackPath: router.pathname,
  trackFeature: form.title,
});
  
// The markup remains legible, even though there are a many props on each element:
  
<MyButton icon={<Icon name="arrow-left" />} href="/" variant="text"> back</MyButton>
  
<MyButton icon={<Icon name="stop-watch" />} onClick={handleSave} variant="outlined" loading={saving}>
  Save draft
</MyButton>
  
<MyButton
  textcolor="cta"
  icon={<Icon name="thumbs-up" />}
  onClick={handleSubmit}
  loading={saving || submitting}
  ssDesktop="margin-left:2rem; font-weight:bold;"
  ssPhone="display:block; margin: 1rem 0;"
>
  Submit changes
</MyButton>
`}
/>

<Inline as="b" textcolor="accent">
  ðŸ¤“ The old and new props will be intelligently merged.
</Inline> Style strings and classNames will be added. Other props will be replaced.{' '}
  
If you're setting many props for several components, predefine all the common props, then override unique props per each intance. It's not just convenient, but makes for more readable and maintainable code.
  
There is simply no way to do this sort of thing with regular React and Styled Components. It makes more sense as you add more complexity. 

<Block as="h2" ss="margin-top: 2rem;">3. Normal Styled Components or whatever you use</Block>

The downside is that there is currently no IDE plugin that will add color syntax highlighting to those custom ss/ssLg/ssSm/etc "style strings" props. So that is your choice. As an alternative, you can always use the standard syntax. Or JSS, whatever system you use.

<Code
  ss="font-size: 0.85rem;"
  code={`import styled from 'styled-components';
import Button from '@ps/ui/components/Button';
  
const StyledButton = styled(Button)\`
  /* your styles here - will have syntax highlighting thanks to the vscode-styled-components plugin */
  
  \${props => props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your styled component template literal */
  }
  
  \${props => props.theme.mq.phoneSmall} {
    /* use any props or theme variables inside your styled component template literal */
  }
\`;`} />

**And even predefine props using the provided HOC:**

<Code
  ss="font-size: 0.85rem;"
  code={`import styled from 'styled-components';
import { withButton } from '@ps/ui/components/Button';
  
const MyButton = withButton({
  size: 'small',
  round: true,
  trackPath: router.pathname,
  trackFeature: form.title,
});
  
const StyledButton = styled(MyButton)\`
  /* your styles here - will have syntax highlighting thanks to the vscode-styled-components plugin */
  
  \${props => props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your styled component template literal */
  }
  
  \${props => props.theme.mq.phoneSmall} {
    /* use any props or theme variables inside your styled component template literal */
  }
\`;`} />

Using props inside styled-components template literals is super powerful!  

<Block as="h2" ss="margin-top: 2rem;">You can also use props with those `ss`, `ssSm`, `ssPhoneSmall` props too!</Block>  

They don't just accept strings, but functions too:

- `string`
- `Array<string>`
- `(props:Props) => string`
- `Array<((props:Props) => string)>`

The custom `ss` props have the same magic functionality of styled-components template literals, but in a slightly different format... 

Inside the `ss` prop template literals you can **NOT** do this:

<Code
  ss="font-size: 0.85rem;"
  code={`\`
  /* your styles here */
  
  \${props => props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your styled component template literal */
  }
  
  \${props => props.theme.mq.phoneSmall} {
    /* use any props or theme variables inside your styled component template literal */
  }
\`;`} />

But you **CAN** do this:

<Code
  ss="font-size: 0.85rem;"
  code={`ss: (props) => \`
  /* your styles here */
  
  \${props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your template literal */
  }
  
  \${props.theme.mq.phoneSmall} {
    /* use any props or theme variables inside your template literal */
  }
\`;`} />

Slightly different format than the true `styled-components`, but gets the job done just as well.

</Wrapper>
</ThemeProvider>