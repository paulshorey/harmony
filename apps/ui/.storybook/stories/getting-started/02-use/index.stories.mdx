import { Meta, Story, Canvas } from '@storybook/addon-docs';
import Block from '@ps/ui/components/Block';
import Inline from '@ps/ui/components/Inline';
import CodeInline from '@ps/ui/components/CodeInline';
import ThemeProvider from '@ps/ui/components/ThemeProvider';
import Wrapper from '@ps/ui/.storybook/components/Wrapper';
import {
  Container,
  ButtonCTA,
  CanvasContainer,
  CanvasContent,
  Title,
  Content,
  Button,
} from '@ps/ui/.storybook/components/Components';
import Code from '@ps/ui/components/Code';

<Meta title="Get started/Styles and props" />

<ThemeProvider>
<Wrapper>

# There are multiple ways to use these components:

<br />

## 1. The default export is ready to use

<Code
  ss="font-size: 0.85rem;"
  code={`import Button from "@ps/ui/components/content/Button";
  
<Button 
  variant="outlined" 
  onClick={console.log} 
  ss={(props) => \`
    padding: 1rem \${props.theme.sizes.card.paddingX};
    \${props.theme.mq.desktopLarge} {
      padding: 1rem \${props.theme.sizes.card.paddingX * 2};
    }
  \`}
  ssLg="/* All ss props accept a SCSS string or a function that returns a string. */"
  ssSm="/* Scroll down for more about variables, css\`\` syntax, and limitations. */"
>
  Click me
</Button>`}
/>

<Block as="h2" ss="margin-top: 3rem;">2. HOC like Styled Components</Block>

This library is powered by `@emotion/styled`. Just like <CodeInline code={`styled.button\`\``}/> or <CodeInline code={`styled.div\`\``}/>, you can use <CodeInline code={`withButton()`}/> or <CodeInline code={`withDiv()`}/>  

**An added feature:** pre-define <Inline as="b" textcolor="accent"> props</Inline> as well as styles. This is a great way to keep your code clean, separate markup from style, data-generated props from unique manually added props. Separate concerns: common pre-defined props vs unique per-instance props.

<Code
  ss="font-size: 0.85rem;"
  code={`import { withButton } from "@ps/ui/components/Button";
  
// Pre-define any props you may need. These will apply to all instance:
  
export const MyButton = withButton({
  size: 'small',
  round: true,
  ss: \`
    margin: 0 0.875rem 0.875rem 0; /* and other styles */
  \`,
  ssDesktop: \`
    &:hover { box-shadow: 1px 2px 1px var(--color-cta); } /* add styles in addition to props.ss */
  \`,
  trackPath: router.pathname,
  trackFeature: form.title,
});
  
// The markup remains legible, even though there are a many props and styles on each element:
  
<MyButton icon={<Icon name="arrow-left" />} href="/" variant="text"> back</MyButton>
  
<MyButton icon={<Icon name="stop-watch" />} onClick={handleSave} variant="outlined" loading={saving}>
  Save draft
</MyButton>
  
<MyButton
  textcolor="cta"
  icon={<Icon name="thumbs-up" />}
  onClick={handleSubmit}
  loading={saving || submitting}
  ssDesktop="margin-left:2rem; font-weight:bold;"
  ssPhone="display:block; margin: 1rem 0;"
>
  Submit changes
</MyButton>
`}
/>

<Inline as="b" textcolor="accent">
  ðŸ¤“ The old and new props will be combined.
</Inline> Style strings and classNames will be added. Other props will be replaced.   
  
If you're setting many props for several components, predefine all the common props, then override unique props per each intance. It's not just convenient, but makes for more readable and maintainable code.

<Block as="h2" ss="margin-top: 4rem;">3. Normal Styled Components</Block>

<Code
  ss="font-size: 0.85rem;"
  code={`
import Button from '@ps/ui/components/Button';
  
const StyledButton = styled(Button)\`
  /* your styles here - will have syntax highlighting thanks to the vscode-@emotion/styled plugin */
  
  \${props => props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your styled component template literal */
  }
\`;`} />

**And even predefine props using the provided HOC:**

<Code
  ss="font-size: 0.85rem;"
  code={`
import { withButton } from '@ps/ui/components/Button';
  
const MyButton = withButton({
  ...myProps
});
  
const StyledButton = styled(MyButton)\`
  /* your styles here - will have syntax highlighting thanks to the vscode-@emotion/styled plugin */
  
  \${props => props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your styled component template literal */
  }
\`;`} />
<Block as="h4" ss="font-size: 2rem; font-weight: 600; margin: 4rem 0 0 0;">Use props and theme:</Block>  

SS props don't just accept strings, but also:  

- `string`
- `Array<string>`
- `(props:Props) => string`
- `Array<((props:Props) => string)>`
- the output of `css` template literal function from `@emotion/styled`

To use props or theme variables inside your styled strings, pass a function that returns a string. The first argument to your function will be `props` from the component. It will contain the `theme` of your site.

<Code
  ss="font-size: 0.85rem; pre > * { line-height: 2.5em; }"
  code={`<Button ss={(props) => \`
  /* your styles here */
  
  \${props.theme.mq.desktopLarge} {
    /* use any props or theme variables inside your template literal */
  }
\`} />`} />
<Block as="h4" ss="font-size: 2rem; font-weight: 600; margin: 4rem 0 0 0;">Syntax highlighting:</Block>  

SS props are NOT the same as @emotion/styled template literal functions. So, your IDE will not color these like CSS. UNLESS...

<Code 
  ss="font-size: 0.85rem;"
  code={`import styled, { css } from '@emotion/styled';

<Block as="p" ss={css\`
  /* THIS WILL BE syntax-HIGHLIGHTED by vscode-@emotion/styled plugin (and others)! */
\`}>
  Wrap the string in a css\`...\` template literal to get syntax-highlighting to work.
</Block>`} />
<Block as="h4" ss="font-size: 2rem; font-weight: 600; margin: 4rem 0 0 0;">Limitations:</Block>

Inside the `ss` prop template literals you can **NOT** do this:

<Code
  ss="font-size: 0.85rem;margin-bottom:0;"
  code={`ss: \`
  padding: 1rem \${(props) => props.theme.sizes.card.paddingX};
  \${(props) => props.theme.mq.desktopLarge} {
    padding: 1rem \${(props) => props.theme.sizes.card.paddingX * 2};
  }
\`;`} />

Not even when wrapping it in `css` from `@emotion/styled`...
  
<br />
  
But you <strong>CAN</strong> do this:

<Code
  ss="font-size: 0.85rem;margin-bottom:1.5rem;"
  code={`ss: (props) => \`
  padding: 1rem \${props.theme.sizes.card.paddingX};
  \${props.theme.mq.desktopLarge} {
    padding: 1rem \${props.theme.sizes.card.paddingX * 2};
  }
\`;`} />

Different format than the regular `@emotion/styled`, but gets the job done.  

<br />

**It's actually even better, because **

1. `theme` prop is added by default, 
2. and you just add `(props) => ` once at the top instead of for every time you use any variable.

<br />

But if anyone knows how to (or wants to give it a shot), please please please reach out or contribute!

</Wrapper>
</ThemeProvider>