{' '}

<br />
In the future, would be nice to use <a
  href="https://github.com/BuilderIO/mitosis"
  target="_blank"
>
  Mitosis
</a> to transpile these <Block
  as="strong"
  variant="textColorUnderlined"
  ss="display:inline;"
>
  React
</Block> components to any other JS framework.

This library does **not** attempt to **replace CSS** functionality like so many CSS-in-JS libraries. Instead it lets JS do what it's good at (define logic and state) while letting CSS do what it's good at (setting the color scheme on a parent that can later be accessed from a child element, without having to prop-drill or style each individual element separately). This is "CSS-and-JS" living in harmony.

This library is completely written in Typescript. **Except** for CSS styles. That's because Typescript is actually incapable of checking validity of CSS rules. So, there's no reason to use the more verbose JavaScript notation over the quick and easy CSS strings. For example, you can define the type of `padding` as `string | number`. But then you pass `1rem2rem` or `calc(10%+10px)` and it breaks because it's missing a space. Typescript can't catch that. If you know of a way, please reach out! I'd love to learn.

However, I love Typescript. It's great for almost everything else. So even though CSS and color variables are not typed (because it's pointless and **visual regression** testing is much better for visual stuff anyway), everything else is type safe. At least that's the goal. This library is still very experimental and in flux. Still adding stricter types and unit tests.

<Code
  variant="transparentDark"
  code={`const SvgSparkle = withBlock({
  as: 'svg',
  ss: \`display:inline-block;position:absolute;width:0;height:0;color:var(--colors-accent);\`,
  children: <path d="..." fill="currentColor" />,
});
...
<SvgSparkle ss="top:-1rem;" />multi-repo<SvgSparkle ss="bottom:-1rem;" />`}
/>

There are many UI component libraries out there, especially for React. But they all have limitations. <a>Here's a comparison.</a> Building your own is a big investment and can get messy. Not anymore!

<Code
variant="transparentDark"
code={`import Span from '@ps/ui/components/content/Span';
...

{' '}

<Span variant="gradient" color="accent">
  your own
</Span> <Span variant="textColorUnderline" color="rainbow">
  {' '}
  custom branded{' '}
</Span>
`} caption=
{
  <>
    Easy!{' '}
    <a href="/?path=/docs/about-200--page" target="_top">
      Read about the Media Query shortcuts!
    </a>
  </>
}
/>

<Code
  variant="transparentLight"
  prismTheme={{ plain: { backgroundColor: 'beige' } }}
  code={`<Code 
  variant="transparentDark" 
  code={\`import Span from '@ps/ui/components/content/Span';
  ...
  <Span variant="gradient" color="accent">your own</Span> <Span variant="textColorUnderline" color="rainbow"> custom branded </Span>
  \`}
  caption={<>Easy! And wait till you <a href="/?path=/docs/about-200--page" target="_top">read about the Media Query shortcuts!</a></>}
/>`}
  caption="Here is how the previous component was rendered"
/>

<br />

## Compatible with most component libraries.

**Peer dependencies:**

- React
- Typescript
- @emotion/styled (just like styled-components)
- @emotion/react (load global styles and theme)
- Next (optional, required for components that use next/link) \*/}

<br />

## Putting the "C" back into "CSS"...

The "C" in "CSS" stands for "Cascading" - styles can be applied based on parent/grandparent styles/variables. Unfortunately, this is lost in modern "CSS-in-JS" solutions. They should be called "S-in-JS", but that's not as catchy. ðŸ˜†

This library attempts to bring back inheritance to style rules, but without the class name conflicts. Components should be able to know if they are inside a dark theme or on top of a color gradient, and adjust the text/button colors automatically. Using CSS variables and HTML data attributes, components are able to adapt to their surroundings, without the developer having to set a specific color shade and subtle style rules for each instance of a component

It's a work in progress. This library is not ready for production use yet, but so far it's looking promising! ðŸš€ Now testing and optimizing.
